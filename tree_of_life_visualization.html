<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>ä¸­å›½æŒæœ‰å‹ä¸åŠ¨äº§ABSå¸‚åœº - ç”Ÿå‘½ä¹‹æ ‘å¯è§†åŒ–</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <style>
        body {
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, sans-serif;
            margin: 0;
            padding: 0;
            background: #fafbfc;
            overflow-x: hidden;
        }
        
        .container {
            display: flex;
            height: 100vh;
        }
        
        .sidebar {
            width: 280px;
            background: #fff;
            border-right: 1px solid #e1e5e9;
            padding: 20px;
            overflow-y: auto;
            box-shadow: 2px 0 8px rgba(0,0,0,0.1);
            z-index: 100;
        }
        
        .sidebar h2 {
            margin: 0 0 20px 0;
            font-size: 18px;
            color: #2d3748;
            border-bottom: 2px solid #4f46e5;
            padding-bottom: 10px;
        }
        
        .feature-group {
            margin-bottom: 25px;
        }
        
        .feature-group h3 {
            margin: 0 0 12px 0;
            font-size: 14px;
            color: #4a5568;
            font-weight: 600;
        }
        
        .feature-option {
            display: flex;
            align-items: center;
            padding: 8px 12px;
            margin: 4px 0;
            border-radius: 6px;
            cursor: pointer;
            transition: all 0.2s ease;
            border: 1px solid transparent;
        }
        
        .feature-option:hover {
            background: #f7fafc;
            border-color: #e2e8f0;
        }
        
        .feature-option.selected {
            background: #ebf4ff;
            border-color: #4f46e5;
            color: #4f46e5;
        }
        
        .feature-color {
            width: 16px;
            height: 16px;
            border-radius: 50%;
            margin-right: 10px;
            border: 2px solid #fff;
            box-shadow: 0 1px 3px rgba(0,0,0,0.1);
        }
        
        .feature-label {
            font-size: 13px;
            font-weight: 500;
        }
        
        .stats-section {
            background: #f8fafc;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 20px;
        }
        
        .stats-section h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #4a5568;
            font-weight: 600;
        }
        
        .stat-item {
            display: flex;
            justify-content: space-between;
            margin: 6px 0;
            font-size: 12px;
        }
        
        .stat-label {
            color: #718096;
        }
        
        .stat-value {
            color: #2d3748;
            font-weight: 600;
        }
        
        .chart-area {
            flex: 1;
            position: relative;
            background: #fff;
        }
        
        .chart-container {
            width: 100%;
            height: 100%;
            position: relative;
        }
        
        .branch {
            fill: none;
            stroke: #cbd5e0;
            stroke-width: 1.5;
            transition: all 0.3s ease;
        }
        
        .branch:hover {
            stroke: #4f46e5;
            stroke-width: 2.5;
        }
        
        .node {
            cursor: pointer;
        }
        
        .node:hover {
        }
        
        .node-circle {
            /* ç§»é™¤å›ºå®šçš„fillé¢œè‰²ï¼Œè®©JavaScriptåŠ¨æ€è®¾ç½® */
            stroke: #cbd5e0;
            stroke-width: 2;
        }
        
        .node-label {
            font-size: 11px;
            fill: #4a5568;
            text-anchor: start;
            pointer-events: none;
        }
        
        .node-label.internal {
            font-size: 10px;
            fill: #718096;
        }
        
        .tooltip {
            position: absolute;
            background: rgba(0, 0, 0, 0.9);
            color: white;
            padding: 12px 16px;
            border-radius: 8px;
            font-size: 12px;
            pointer-events: none;
            z-index: 1000;
            max-width: 300px;
            box-shadow: 0 4px 12px rgba(0,0,0,0.15);
            opacity: 0;
            transition: opacity 0.2s ease;
        }
        
        .legend {
            position: absolute;
            top: 20px;
            right: 20px;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 8px;
            padding: 15px;
            box-shadow: 0 2px 8px rgba(0,0,0,0.1);
            max-width: 250px;
        }
        
        .legend h4 {
            margin: 0 0 10px 0;
            font-size: 13px;
            color: #2d3748;
            font-weight: 600;
        }
        
        .legend-item {
            display: flex;
            align-items: center;
            margin: 6px 0;
            font-size: 11px;
        }
        
        .legend-color {
            width: 12px;
            height: 12px;
            border-radius: 50%;
            margin-right: 8px;
            border: 1px solid #e2e8f0;
        }
        
        .search-box {
            width: 100%;
            padding: 8px 12px;
            border: 1px solid #e2e8f0;
            border-radius: 6px;
            font-size: 13px;
            margin-bottom: 15px;
        }
        
        .search-box:focus {
            outline: none;
            border-color: #4f46e5;
            box-shadow: 0 0 0 3px rgba(79, 70, 229, 0.1);
        }
        
        .node.highlighted {
            filter: drop-shadow(0 0 8px #ffd700);
        }
        
        .node.highlighted .node-circle {
            stroke: #ffd700;
            stroke-width: 3px;
        }
        
        .node.highlighted .node-label {
            font-weight: bold;
            fill: #d97706;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="sidebar">
            <h2>æŒæœ‰å‹ä¸åŠ¨äº§ABSå¸‚åœºåˆ†ææ§åˆ¶å°</h2>
            
            <input type="text" class="search-box" placeholder="æœç´¢äº§å“æˆ–æœºæ„..." id="search-input">
            
            <div class="stats-section">
                <h4>å¸‚åœºæ¦‚è§ˆ</h4>
                <div class="stat-item">
                    <span class="stat-label">æ€»äº§å“æ•°</span>
                    <span class="stat-value" id="total-products">17</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">æ€»è§„æ¨¡</span>
                    <span class="stat-value" id="total-scale">324.8äº¿å…ƒ</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">å·²å‘è¡Œ</span>
                    <span class="stat-value" id="issued-products">10</span>
                </div>
                <div class="stat-item">
                    <span class="stat-label">æ‰¿é”€æœºæ„</span>
                    <span class="stat-value" id="underwriter-count">8</span>
                </div>
            </div>
            
            <div class="feature-group">
                <h3>ç€è‰²ç‰¹å¾</h3>
                <div id="color-features"></div>
            </div>
            
            <div class="feature-group">
                <h3>å¤§å°ç‰¹å¾</h3>
                <div id="size-features"></div>
            </div>
            
            <div class="feature-group">
                <h3>è¿‡æ»¤é€‰é¡¹</h3>
                <div id="filter-options"></div>
            </div>
        </div>
        
        <div class="chart-area">
            <div class="chart-container">
                <svg id="tree-svg"></svg>
                <div class="tooltip" id="tooltip"></div>
                <div class="legend" id="legend"></div>
            </div>
        </div>
    </div>

    <script>
        // CSVæ•°æ® - åŸºäºintegrated ABS.csv
        const csvData = `Product_Name,Lead_Underwriter,Scale_Billion_Yuan,Status,Application_Date,Approval_Date,Asset_Category,Underlying_Asset_Type,Third_Party_Certification,Special_Features
æ³°åº·èµ„äº§-è´¢é€š-è¿œæ™¯æ–°èƒ½æºæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’(ç¢³ä¸­å’Œ),æ³°åº·èµ„äº§,2.85,å·²å‘è¡Œ,2025-03-31,2025-05-19,æŒæœ‰å‹ä¸åŠ¨äº§ABS,èƒ½æºè®¾æ–½,ç¢³ä¸­å’Œè®¤è¯,æ–°èƒ½æºé¡¹ç›®
å¤ªå¹³æ´‹-ä¸–çºªäº’è”æ•°æ®ä¸­å¿ƒæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,å¤ªå¹³æ´‹èµ„äº§,8.6,å·²å‘è¡Œ,2025-02-21,2025-05-09,æŒæœ‰å‹ä¸åŠ¨äº§ABS,æ•°æ®ä¸­å¿ƒ,æ— è®¤è¯,æ•°æ®ä¸­å¿ƒèµ„äº§
å¹¿æ˜é«˜é€ŸæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,äººä¿èµ„äº§,25.3,å·²å‘è¡Œ,2024-11-21,2025-03-12,æŒæœ‰å‹ä¸åŠ¨äº§ABS,é«˜é€Ÿå…¬è·¯,æ— è®¤è¯,åŸºç¡€è®¾æ–½é¡¹ç›®
ä¸­ä¿¡è¯åˆ¸-ä¸‡å›½æ•°æ®2025å¹´ç¬¬1æœŸæ•°æ®ä¸­å¿ƒæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,ä¸­ä¿¡è¯åˆ¸,16.09,å·²å‘è¡Œ,2024-07-18,2025-01-23,æŒæœ‰å‹ä¸åŠ¨äº§ABS,æ•°æ®ä¸­å¿ƒ,æ— è®¤è¯,å…¨å›½é¦–å•æ•°æ®ä¸­å¿ƒæŒæœ‰å‹ä¸åŠ¨äº§ABS
å»ºä¿¡ä½æˆ¿ç§ŸèµåŸºé‡‘æŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,ä¸­é‡‘å…¬å¸,11.7,å·²å‘è¡Œ,2024-03-30,2024-07-30,æŒæœ‰å‹ä¸åŠ¨äº§ABS,ä½æˆ¿ç§Ÿèµ,æ— è®¤è¯,ä½æˆ¿ç§Ÿèµé¢†åŸŸ
å¹³å®‰è¯åˆ¸-ä¸­å›½é“å»ºä¸€æœŸæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,å¹³å®‰è¯åˆ¸,8.58,å·²å‘è¡Œ,2024-11-26,2024-12-25,æŒæœ‰å‹ä¸åŠ¨äº§ABS,åŸºç¡€è®¾æ–½,æ— è®¤è¯,é“å»ºé¡¹ç›®
ä¹æ°¸é«˜é€ŸæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,åæ³°èµ„ç®¡,22.0,å·²å‘è¡Œ,2024-09-23,2024-11-22,æŒæœ‰å‹ä¸åŠ¨äº§ABS,é«˜é€Ÿå…¬è·¯,æ— è®¤è¯,é«˜é€Ÿå…¬è·¯é¡¹ç›®
å®‰æ±Ÿé«˜é€ŸæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,ä¸­é‡‘å…¬å¸,49.56,å·²å‘è¡Œ,2024-06-27,2024-07-22,æŒæœ‰å‹ä¸åŠ¨äº§ABS,é«˜é€Ÿå…¬è·¯,æ— è®¤è¯,é«˜é€Ÿå…¬è·¯é¡¹ç›®
åæ³°-ä¸­äº¤è·¯å»ºæ¸…è¥¿å¤§æ¡¥æŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,åæ³°èµ„ç®¡,19.6,å·²å‘è¡Œ,2023-11-13,2023-12-11,æŒæœ‰å‹ä¸åŠ¨äº§ABS,åŸºç¡€è®¾æ–½,æ— è®¤è¯,é¦–åªæŒæœ‰å‹REITsäº§å“
ä¸­ä¿¡è¯åˆ¸-è¶Šç§€å•†ä¸šæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,ä¸­ä¿¡è¯åˆ¸,14.3,å·²å‘è¡Œ,2024-09-20,2024-10-28,æŒæœ‰å‹ä¸åŠ¨äº§ABS,å•†ä¸šåœ°äº§,æ— è®¤è¯,å•†ä¸šåœ°äº§é¡¹ç›®
å›½é‡‘èµ„ç®¡-æ–°ç–†å›½ä¿¡æŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’èµ„äº§æ”¯æŒè¯åˆ¸ï¼ˆç«ç”µï¼‰,å›½é‡‘èµ„ç®¡,55.0,å·²ç”³æŠ¥,2025-04-30,2025-05-14,æŒæœ‰å‹ä¸åŠ¨äº§ABS,èƒ½æºè®¾æ–½,æ— è®¤è¯,ç«ç”µé¡¹ç›®
ä¸œç™¾é›†å›¢ä»“å‚¨ç‰©æµæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,ä¸­é‡‘å…¬å¸,15.02,å·²ç”³æŠ¥,2025-03-31,2025-04-15,æŒæœ‰å‹ä¸åŠ¨äº§ABS,ç‰©æµä»“å‚¨,æ— è®¤è¯,ç‰©æµä»“å‚¨é¡¹ç›®
å›½é‡‘èµ„ç®¡-è§‚åšå•ŸåŸæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’ï¼ˆç”Ÿç‰©åŒ»è¯äº§ä¸šå›­ï¼‰,å›½é‡‘èµ„ç®¡,4.99,å·²ç”³æŠ¥,2025-03-31,2025-04-13,æŒæœ‰å‹ä¸åŠ¨äº§ABS,äº§ä¸šå›­åŒº,æ— è®¤è¯,ç”Ÿç‰©åŒ»è¯äº§ä¸šå›­
ä¸­é‡‘å‡¯å¾·å•†ä¸šæŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,ä¸­é‡‘å…¬å¸,30.0,å·²ç”³æŠ¥,2025-03-31,2025-05-22,æŒæœ‰å‹ä¸åŠ¨äº§ABS,å•†ä¸šåœ°äº§,æ— è®¤è¯,å•†ä¸šåœ°äº§é¡¹ç›®
äººä¿èµ„äº§-ä¸­é“è¯ºå¾·æŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,äººä¿èµ„äº§,25.6,å·²ç”³æŠ¥,2025-03-31,2025-04-08,æŒæœ‰å‹ä¸åŠ¨äº§ABS,åŸºç¡€è®¾æ–½,æ— è®¤è¯,é“å»ºé¡¹ç›®
å›½é‡‘èµ„ç®¡-åŸºæ±‡èµ„æœ¬æŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,å›½é‡‘èµ„ç®¡,8.67,å·²ç”³æŠ¥,2025-02-19,2025-04-22,æŒæœ‰å‹ä¸åŠ¨äº§ABS,å•†ä¸šåœ°äº§,æ— è®¤è¯,å•†ä¸šåœ°äº§é¡¹ç›®
å›½é‡‘èµ„ç®¡-æ¬¢ä¹é¢‚æŒæœ‰å‹ä¸åŠ¨äº§èµ„äº§æ”¯æŒä¸“é¡¹è®¡åˆ’,å›½é‡‘èµ„ç®¡,6.95,å·²ç”³æŠ¥,2024-12-06,2025-03-19,æŒæœ‰å‹ä¸åŠ¨äº§ABS,å•†ä¸šåœ°äº§,æ— è®¤è¯,å•†ä¸šåœ°äº§é¡¹ç›®`;

        // è§£æå’Œæ¸…ç†æ•°æ®
        const data = d3.csvParse(csvData);
        const cleanedData = data.map(d => ({
            ...d,
            Scale_Billion_Yuan: d.Scale_Billion_Yuan ? +d.Scale_Billion_Yuan : 0,
            Lead_Underwriter: d.Lead_Underwriter || 'å…¶ä»–',
            Third_Party_Certification: d.Third_Party_Certification === 'æ— è®¤è¯' ? 'æ— è®¤è¯' : d.Third_Party_Certification,
            // æ·»åŠ ç»¿è‰²è®¤è¯åˆ¤æ–­
            IsGreen: d.Third_Party_Certification === 'ç¢³ä¸­å’Œè®¤è¯' || d.Special_Features?.includes('æ–°èƒ½æº') || d.Special_Features?.includes('ç»¿è‰²')
        }));

        // ç‰¹å¾å®šä¹‰
        const features = {
            color: [
                { id: 'Asset_Category', name: 'èµ„äº§ç±»åˆ«', type: 'categorical' },
                { id: 'Lead_Underwriter', name: 'æ‰¿é”€å•†', type: 'categorical' },
                { id: 'Underlying_Asset_Type', name: 'åº•å±‚èµ„äº§', type: 'categorical' },
                { id: 'Third_Party_Certification', name: 'è®¤è¯æœºæ„', type: 'categorical' },
                { id: 'Status', name: 'å‘è¡ŒçŠ¶æ€', type: 'categorical' },
                { id: 'Scale_Billion_Yuan', name: 'å‘è¡Œè§„æ¨¡', type: 'continuous' },
                { id: 'IsGreen', name: 'ç»¿è‰²è®¤è¯', type: 'categorical' }
            ],
            size: [
                { id: 'Scale_Billion_Yuan', name: 'å‘è¡Œè§„æ¨¡', type: 'continuous' },
                { id: 'none', name: 'ç»Ÿä¸€å¤§å°', type: 'none' }
            ],
            filter: [
                { id: 'Asset_Category', name: 'æŒ‰èµ„äº§ç±»åˆ«', type: 'categorical' },
                { id: 'Lead_Underwriter', name: 'æŒ‰æ‰¿é”€å•†', type: 'categorical' },
                { id: 'Status', name: 'æŒ‰å‘è¡ŒçŠ¶æ€', type: 'categorical' },
                { id: 'Underlying_Asset_Type', name: 'æŒ‰åº•å±‚èµ„äº§', type: 'categorical' }
            ]
        };

        // åˆå§‹åŒ–é¢œè‰²æ–¹æ¡ˆ - ä½¿ç”¨ç®€å•å¯é çš„é¢œè‰²æ˜ å°„
        function initializeColorSchemes() {
            console.log(`ğŸ¨ [INIT] Initializing color schemes...`);
            
            const schemes = {};
            
            // èµ„äº§ç±»åˆ« - ç®€å•æ˜ç¡®çš„é¢œè‰²
            schemes.Asset_Category = function(value) {
                const colorMap = {
                    'æŒæœ‰å‹ä¸åŠ¨äº§ABS': '#3b82f6'
                };
                return colorMap[value] || '#6b7280';
            };
            
            // æ‰¿é”€å•† - ä¸åŒçš„æ˜äº®é¢œè‰²
            schemes.Lead_Underwriter = function(value) {
                const colorMap = {
                    'ä¸­é‡‘å…¬å¸': '#8b5cf6',
                    'å›½é‡‘èµ„ç®¡': '#f59e0b', 
                    'äººä¿èµ„äº§': '#ef4444',
                    'ä¸­ä¿¡è¯åˆ¸': '#06b6d4',
                    'åæ³°èµ„ç®¡': '#84cc16',
                    'å¹³å®‰è¯åˆ¸': '#f97316',
                    'æ³°åº·èµ„äº§': '#ec4899',
                    'å¤ªå¹³æ´‹èµ„äº§': '#14b8a6',
                    'å…¶ä»–': '#6b7280'
                };
                return colorMap[value] || '#6b7280';
            };
            
            // åº•å±‚èµ„äº§ç±»å‹ - ä¸°å¯Œçš„é¢œè‰²è°ƒè‰²æ¿
            schemes.Underlying_Asset_Type = function(value) {
                const colorMap = {
                    'æ•°æ®ä¸­å¿ƒ': '#8b5cf6',
                    'é«˜é€Ÿå…¬è·¯': '#3b82f6',
                    'ä½æˆ¿ç§Ÿèµ': '#10b981',
                    'åŸºç¡€è®¾æ–½': '#f59e0b',
                    'å•†ä¸šåœ°äº§': '#ef4444',
                    'èƒ½æºè®¾æ–½': '#06b6d4',
                    'ç‰©æµä»“å‚¨': '#84cc16',
                    'äº§ä¸šå›­åŒº': '#f97316',
                    'å…¶ä»–': '#6b7280'
                };
                return colorMap[value] || '#6b7280';
            };
            
            // è®¤è¯æœºæ„ - ç»¿è‰²ç³»ä¸ºä¸»
            schemes.Third_Party_Certification = function(value) {
                const colorMap = {
                    'ç¢³ä¸­å’Œè®¤è¯': '#10b981',
                    'æ— è®¤è¯': '#6b7280'
                };
                return colorMap[value] || '#6b7280';
            };
            
            // å‘è¡ŒçŠ¶æ€ - çŠ¶æ€æŒ‡ç¤ºè‰²
            schemes.Status = function(value) {
                const colorMap = {
                    'å·²å‘è¡Œ': '#10b981',
                    'å·²ç”³æŠ¥': '#f59e0b'
                };
                return colorMap[value] || '#6b7280';
            };
            
            // å‘è¡Œè§„æ¨¡ - è¿ç»­è‰²å½©
            schemes.Scale_Billion_Yuan = function(value) {
                if (!value || value === 0) return '#e5e7eb';
                
                // ä½¿ç”¨ç®€å•çš„çº¿æ€§æ˜ å°„
                const maxScale = 55; // æœ€å¤§è§„æ¨¡çº¦55äº¿
                const ratio = Math.min(value / maxScale, 1);
                
                // ä»æµ…è“åˆ°æ·±è“çš„æ¸å˜
                const r = Math.round(59 + (16 - 59) * ratio);
                const g = Math.round(130 + (185 - 130) * ratio);
                const b = Math.round(246 + (248 - 246) * ratio);
                
                return `rgb(${r}, ${g}, ${b})`;
            };
            
            // ç»¿è‰²è®¤è¯ - ç»¿è‰²ç³»
            schemes.IsGreen = function(value) {
                const colorMap = {
                    'true': '#10b981',
                    'false': '#6b7280'
                };
                return colorMap[String(value)] || '#6b7280';
            };
            
            console.log(`ğŸ¨ [INIT] Color schemes initialized:`, Object.keys(schemes));
            return schemes;
        }

        // é¢œè‰²æ–¹æ¡ˆ
        const colorSchemes = initializeColorSchemes();

        // æµ‹è¯•é¢œè‰²æ–¹æ¡ˆ
        function testColorSchemes() {
            console.log(`ğŸ§ª [TEST] Testing color schemes...`);
            
            // æµ‹è¯•èµ„äº§ç±»åˆ«
            console.log(`ğŸ§ª Asset_Category colors:`);
            console.log(`  æŒæœ‰å‹ä¸åŠ¨äº§ABS: ${colorSchemes.Asset_Category('æŒæœ‰å‹ä¸åŠ¨äº§ABS')}`);
            
            // æµ‹è¯•æ‰¿é”€å•†
            console.log(`ğŸ§ª Lead_Underwriter colors:`);
            console.log(`  ä¸­é‡‘å…¬å¸: ${colorSchemes.Lead_Underwriter('ä¸­é‡‘å…¬å¸')}`);
            console.log(`  å›½é‡‘èµ„ç®¡: ${colorSchemes.Lead_Underwriter('å›½é‡‘èµ„ç®¡')}`);
            
            // æµ‹è¯•è®¤è¯æœºæ„
            console.log(`ğŸ§ª Third_Party_Certification colors:`);
            console.log(`  ç¢³ä¸­å’Œè®¤è¯: ${colorSchemes.Third_Party_Certification('ç¢³ä¸­å’Œè®¤è¯')}`);
            console.log(`  æ— è®¤è¯: ${colorSchemes.Third_Party_Certification('æ— è®¤è¯')}`);
            
            // æµ‹è¯•ç»¿è‰²è®¤è¯
            console.log(`ğŸ§ª IsGreen colors:`);
            console.log(`  true: ${colorSchemes.IsGreen(true)}`);
            console.log(`  false: ${colorSchemes.IsGreen(false)}`);
        }
        
        // æ‰§è¡Œæµ‹è¯•
        testColorSchemes();

        // Tree of Life å¯è§†åŒ–ç±»
        class TreeOfLifeVisualization {
            constructor() {
                this.width = window.innerWidth - 280;
                this.height = window.innerHeight;
                this.radius = Math.min(this.width, this.height) / 2 - 150; // å¢åŠ è¾¹è·
                
                this.currentColorFeature = 'Asset_Category';
                this.currentSizeFeature = 'Scale_Billion_Yuan';
                this.currentFilter = null;
                this.searchTerm = '';
                
                this.svg = d3.select("#tree-svg")
                    .attr("width", this.width)
                    .attr("height", this.height);
                
                this.g = this.svg.append("g")
                    .attr("transform", `translate(${this.width/2},${this.height/2})`);
                
                this.tooltip = d3.select("#tooltip");
                
                // é˜²é‡å å‚æ•°
                this.minNodeDistance = 30;
                this.minLabelDistance = 15;
                
                this.init();
            }
            
            init() {
                this.setupSidebar();
                this.createTreeStructure();
                this.render();
                this.setupEventListeners();
            }
            
            setupSidebar() {
                // è®¾ç½®é¢œè‰²ç‰¹å¾é€‰é¡¹
                const colorContainer = d3.select("#color-features");
                features.color.forEach(feature => {
                    const option = colorContainer.append("div")
                        .attr("class", "feature-option")
                        .classed("selected", feature.id === this.currentColorFeature);
                    
                    const color = this.getFeatureColor(feature.id);
                    option.append("div")
                        .attr("class", "feature-color")
                        .style("background", color);
                    
                    option.append("span")
                        .attr("class", "feature-label")
                        .text(feature.name);
                    
                    option.on("click", () => {
                        console.log(`ğŸ¨ Color feature changed to: ${feature.id}`);
                        colorContainer.selectAll(".feature-option").classed("selected", false);
                        option.classed("selected", true);
                        this.currentColorFeature = feature.id;
                        
                        console.log(`ğŸ¨ Current color scheme available:`, !!colorSchemes[feature.id]);
                        this.updateVisualization();
                    });
                });
                
                // è®¾ç½®å¤§å°ç‰¹å¾é€‰é¡¹
                const sizeContainer = d3.select("#size-features");
                features.size.forEach(feature => {
                    const option = sizeContainer.append("div")
                        .attr("class", "feature-option")
                        .classed("selected", feature.id === this.currentSizeFeature);
                    
                    option.append("div")
                        .attr("class", "feature-color")
                        .style("background", "#cbd5e0");
                    
                    option.append("span")
                        .attr("class", "feature-label")
                        .text(feature.name);
                    
                    option.on("click", () => {
                        sizeContainer.selectAll(".feature-option").classed("selected", false);
                        option.classed("selected", true);
                        this.currentSizeFeature = feature.id;
                        this.updateVisualization();
                    });
                });
                
                // è®¾ç½®è¿‡æ»¤é€‰é¡¹
                const filterContainer = d3.select("#filter-options");
                features.filter.forEach(feature => {
                    const option = filterContainer.append("div")
                        .attr("class", "feature-option");
                    
                    option.append("div")
                        .attr("class", "feature-color")
                        .style("background", "#e2e8f0");
                    
                    option.append("span")
                        .attr("class", "feature-label")
                        .text(feature.name);
                    
                    option.on("click", () => {
                        const isSelected = option.classed("selected");
                        filterContainer.selectAll(".feature-option").classed("selected", false);
                        if (!isSelected) {
                            option.classed("selected", true);
                            this.currentFilter = feature.id;
                        } else {
                            this.currentFilter = null;
                        }
                        this.updateVisualization();
                    });
                });
            }
            
            getFeatureColor(featureId) {
                // è·å–ç‰¹å¾çš„ç¤ºä¾‹é¢œè‰²ç”¨äºsidebaræ˜¾ç¤º
                if (colorSchemes[featureId]) {
                    if (featureId === 'Asset_Category') {
                        return colorSchemes[featureId]('æŒæœ‰å‹ä¸åŠ¨äº§ABS');
                    } else if (featureId === 'Lead_Underwriter') {
                        return colorSchemes[featureId]('ä¸­é‡‘å…¬å¸');
                    } else if (featureId === 'Underlying_Asset_Type') {
                        return colorSchemes[featureId]('æ•°æ®ä¸­å¿ƒ');
                    } else if (featureId === 'Third_Party_Certification') {
                        return colorSchemes[featureId]('ç¢³ä¸­å’Œè®¤è¯');
                    } else if (featureId === 'Status') {
                        return colorSchemes[featureId]('å·²å‘è¡Œ');
                    } else if (featureId === 'Scale_Billion_Yuan') {
                        return colorSchemes[featureId](25);
                    } else if (featureId === 'IsGreen') {
                        return colorSchemes[featureId](true);
                    }
                }
                return "#cbd5e0";
            }
            
            getNodeColor(d) {
                const feature = this.currentColorFeature;
                
                console.log(`ğŸ¨ [COLOR] Getting color for node: ${d.data.name}, type: ${d.data.type}, feature: ${feature}`);
                
                // æ ¹èŠ‚ç‚¹ç‰¹æ®Šå¤„ç†
                if (d.data.type === 'root') {
                    console.log(`ğŸ¨ [COLOR] Root node, returning light gray`);
                    return "#f8fafc";
                }
                
                let colorValue = null;
                
                // 1. äº§å“èŠ‚ç‚¹ï¼šç›´æ¥ä»æ•°æ®è·å–ç‰¹å¾å€¼
                if (d.data.type === 'product' && d.data.data) {
                    colorValue = d.data.data[feature];
                    console.log(`ğŸ¨ [COLOR] Product node, feature value: ${colorValue}`);
                }
                // 2. ä¸­é—´èŠ‚ç‚¹ï¼šæ ¹æ®èŠ‚ç‚¹ç±»å‹å’Œå½“å‰ç‰¹å¾åŒ¹é…
                else {
                    // å¦‚æœèŠ‚ç‚¹ç±»å‹ä¸å½“å‰ç‰¹å¾å®Œå…¨åŒ¹é…ï¼Œä½¿ç”¨èŠ‚ç‚¹åç§°
                    if ((d.data.type === 'category' && feature === 'Asset_Category') ||
                        (d.data.type === 'underwriter' && feature === 'Lead_Underwriter') ||
                        (d.data.type === 'asset_type' && feature === 'Underlying_Asset_Type') ||
                        (d.data.type === 'certification' && feature === 'Third_Party_Certification') ||
                        (d.data.type === 'status' && feature === 'Status')) {
                        colorValue = d.data.name;
                        console.log(`ğŸ¨ [COLOR] Direct type match, using node name: ${colorValue}`);
                    }
                    // å¦åˆ™ä½¿ç”¨èšåˆæ•°æ®çš„ä¸»å¯¼å€¼
                    else if (d.data.aggregatedData && d.data.aggregatedData.dominantValue) {
                        colorValue = d.data.aggregatedData.dominantValue;
                        console.log(`ğŸ¨ [COLOR] Using dominant value: ${colorValue}`);
                    }
                }
                
                // 3. è·å–é¢œè‰²
                if (colorValue && colorValue !== 'N/A' && colorSchemes[feature]) {
                    const color = colorSchemes[feature](colorValue);
                    console.log(`ğŸ¨ [COLOR] âœ… Final color: ${color} for value: ${colorValue}`);
                    return color;
                }
                
                // 4. å‘è¡Œè§„æ¨¡ç‰¹æ®Šå¤„ç†
                if (feature === 'Scale_Billion_Yuan' && d.data.aggregatedData) {
                    const value = d.data.aggregatedData.totalScale || 0;
                    if (value > 0) {
                        const color = colorSchemes[feature](value);
                        console.log(`ğŸ¨ [COLOR] âœ… Scale color: ${color} for value: ${value}`);
                        return color;
                    }
                }
                
                console.log(`ğŸ¨ [COLOR] âŒ No color found, using default`);
                return "#e5e7eb";
            }
            
            createTreeStructure() {
                // åˆ›å»ºå±‚æ¬¡ç»“æ„ï¼Œå¢åŠ é—´è·ä»¥é˜²æ­¢é‡å 
                const hierarchy = {
                    name: "ABSç”Ÿæ€ç³»ç»Ÿ",
                    type: 'root',
                    children: []
                };
                
                const feature = this.currentColorFeature;
                
                if (feature === 'Asset_Category') {
                    this.createHierarchyByAssetCategory(hierarchy);
                } else if (feature === 'Lead_Underwriter') {
                    this.createHierarchyByUnderwriter(hierarchy);
                } else if (feature === 'Underlying_Asset_Type') {
                    this.createHierarchyByAssetType(hierarchy);
                } else if (feature === 'Third_Party_Certification') {
                    this.createHierarchyByCertification(hierarchy);
                } else if (feature === 'Status') {
                    this.createHierarchyByStatus(hierarchy);
                } else {
                    this.createHierarchyByAssetCategory(hierarchy);
                }
                
                this.hierarchyData = hierarchy;
            }
            
            createHierarchyByAssetCategory(hierarchy) {
                const assetGroups = d3.group(cleanedData, d => d.Asset_Category);
                
                assetGroups.forEach((products, assetCategory) => {
                    const assetNode = {
                        name: assetCategory,
                        type: 'category',
                        value: assetCategory,
                        aggregatedData: this.calculateAggregatedData(products),
                        children: []
                    };
                    
                    const underwriterGroups = d3.group(products, d => d.Lead_Underwriter);
                    underwriterGroups.forEach((underwriterProducts, underwriter) => {
                        const underwriterNode = {
                            name: underwriter,
                            type: 'underwriter',
                            value: underwriter,
                            aggregatedData: this.calculateAggregatedData(underwriterProducts),
                            children: underwriterProducts.map(product => ({
                                name: product.Product_Name,
                                type: 'product',
                                value: product[this.currentColorFeature] || product.Asset_Category,
                                data: product,
                                aggregatedData: { 
                                    totalScale: product.Scale_Billion_Yuan,
                                    count: 1,
                                    avgScale: product.Scale_Billion_Yuan
                                }
                            }))
                        };
                        assetNode.children.push(underwriterNode);
                    });
                    
                    hierarchy.children.push(assetNode);
                });
            }
            
            createHierarchyByUnderwriter(hierarchy) {
                const underwriterGroups = d3.group(cleanedData, d => d.Lead_Underwriter);
                
                underwriterGroups.forEach((products, underwriter) => {
                    const underwriterNode = {
                        name: underwriter,
                        type: 'underwriter',
                        value: underwriter,
                        aggregatedData: this.calculateAggregatedData(products),
                        children: []
                    };
                    
                    const assetGroups = d3.group(products, d => d.Asset_Category);
                    assetGroups.forEach((assetProducts, assetCategory) => {
                        const assetNode = {
                            name: assetCategory,
                            type: 'category',
                            value: assetCategory,
                            aggregatedData: this.calculateAggregatedData(assetProducts),
                            children: assetProducts.map(product => ({
                                name: product.Product_Name,
                                type: 'product',
                                value: product[this.currentColorFeature] || product.Lead_Underwriter,
                                data: product,
                                aggregatedData: { 
                                    totalScale: product.Scale_Billion_Yuan,
                                    count: 1,
                                    avgScale: product.Scale_Billion_Yuan
                                }
                            }))
                        };
                        underwriterNode.children.push(assetNode);
                    });
                    
                    hierarchy.children.push(underwriterNode);
                });
            }
            
            createHierarchyByAssetType(hierarchy) {
                const assetTypeGroups = d3.group(cleanedData, d => d.Underlying_Asset_Type);
                
                assetTypeGroups.forEach((products, assetType) => {
                    const assetTypeNode = {
                        name: assetType,
                        type: 'asset_type',
                        value: assetType,
                        aggregatedData: this.calculateAggregatedData(products),
                        children: []
                    };
                    
                    const assetGroups = d3.group(products, d => d.Asset_Category);
                    assetGroups.forEach((assetProducts, assetCategory) => {
                        const assetNode = {
                            name: assetCategory,
                            type: 'category',
                            value: assetCategory,
                            aggregatedData: this.calculateAggregatedData(assetProducts),
                            children: assetProducts.map(product => ({
                                name: product.Product_Name,
                                type: 'product',
                                value: product[this.currentColorFeature] || product.Underlying_Asset_Type,
                                data: product,
                                aggregatedData: { 
                                    totalScale: product.Scale_Billion_Yuan,
                                    count: 1,
                                    avgScale: product.Scale_Billion_Yuan
                                }
                            }))
                        };
                        assetTypeNode.children.push(assetNode);
                    });
                    
                    hierarchy.children.push(assetTypeNode);
                });
            }
            
            createHierarchyByCertification(hierarchy) {
                const certGroups = d3.group(cleanedData, d => d.Third_Party_Certification);
                
                certGroups.forEach((products, certification) => {
                    const certNode = {
                        name: certification,
                        type: 'certification',
                        value: certification,
                        aggregatedData: this.calculateAggregatedData(products),
                        children: []
                    };
                    
                    const assetGroups = d3.group(products, d => d.Asset_Category);
                    assetGroups.forEach((assetProducts, assetCategory) => {
                        const assetNode = {
                            name: assetCategory,
                            type: 'category',
                            value: assetCategory,
                            aggregatedData: this.calculateAggregatedData(assetProducts),
                            children: assetProducts.map(product => ({
                                name: product.Product_Name,
                                type: 'product',
                                value: product[this.currentColorFeature] || product.Third_Party_Certification,
                                data: product,
                                aggregatedData: { 
                                    totalScale: product.Scale_Billion_Yuan,
                                    count: 1,
                                    avgScale: product.Scale_Billion_Yuan
                                }
                            }))
                        };
                        certNode.children.push(assetNode);
                    });
                    
                    hierarchy.children.push(certNode);
                });
            }
            
            createHierarchyByStatus(hierarchy) {
                const statusGroups = d3.group(cleanedData, d => d.Status);
                
                statusGroups.forEach((products, status) => {
                    const statusNode = {
                        name: status,
                        type: 'status',
                        value: status,
                        aggregatedData: this.calculateAggregatedData(products),
                        children: []
                    };
                    
                    const assetGroups = d3.group(products, d => d.Asset_Category);
                    assetGroups.forEach((assetProducts, assetCategory) => {
                        const assetNode = {
                            name: assetCategory,
                            type: 'category',
                            value: assetCategory,
                            aggregatedData: this.calculateAggregatedData(assetProducts),
                            children: assetProducts.map(product => ({
                                name: product.Product_Name,
                                type: 'product',
                                value: product[this.currentColorFeature] || product.Status,
                                data: product,
                                aggregatedData: { 
                                    totalScale: product.Scale_Billion_Yuan,
                                    count: 1,
                                    avgScale: product.Scale_Billion_Yuan
                                }
                            }))
                        };
                        statusNode.children.push(assetNode);
                    });
                    
                    hierarchy.children.push(statusNode);
                });
            }
            
            calculateAggregatedData(products) {
                const totalScale = products.reduce((sum, d) => sum + d.Scale_Billion_Yuan, 0);
                const count = products.length;
                const avgScale = totalScale / count;
                
                // è®¡ç®—å½“å‰ç‰¹å¾çš„ä¸»è¦å€¼ï¼ˆä¼—æ•°ï¼‰
                const featureValues = products
                    .map(d => d[this.currentColorFeature])
                    .filter(v => v && v !== 'N/A' && v !== null && v !== undefined);
                
                console.log(`ğŸ“Š [AGGREGATED] Calculating for ${products.length} products, feature: ${this.currentColorFeature}`);
                console.log(`ğŸ“Š [AGGREGATED] Feature values:`, featureValues);
                
                // å¦‚æœæ²¡æœ‰æœ‰æ•ˆçš„ç‰¹å¾å€¼ï¼Œè¿”å›åŸºæœ¬èšåˆæ•°æ®
                if (featureValues.length === 0) {
                    console.log(`ğŸ“Š [AGGREGATED] No valid feature values found`);
                    return {
                        totalScale,
                        count,
                        avgScale,
                        dominantValue: null,
                        products,
                        featureDistribution: {}
                    };
                }
                
                // ç»Ÿè®¡æ¯ä¸ªå€¼çš„å‡ºç°æ¬¡æ•°
                const valueCounts = {};
                featureValues.forEach(v => {
                    valueCounts[v] = (valueCounts[v] || 0) + 1;
                });
                
                // æ‰¾åˆ°å‡ºç°æ¬¡æ•°æœ€å¤šçš„å€¼ï¼ˆä¼—æ•°ï¼‰
                const dominantValue = Object.keys(valueCounts).reduce((a, b) => 
                    valueCounts[a] > valueCounts[b] ? a : b
                );
                
                console.log(`ğŸ“Š [AGGREGATED] Value counts:`, valueCounts);
                console.log(`ğŸ“Š [AGGREGATED] Dominant value: ${dominantValue}`);
                
                return {
                    totalScale,
                    count,
                    avgScale,
                    dominantValue,
                    products,
                    featureDistribution: valueCounts
                };
            }
            
            render() {
                // é‡æ–°åˆ›å»ºæ ‘ç»“æ„ä»¥åæ˜ å½“å‰ç‰¹å¾
                this.createTreeStructure();
                
                // åˆ›å»ºå±‚æ¬¡å¸ƒå±€ï¼Œå¢åŠ åˆ†ç¦»åº¦ä»¥é˜²æ­¢é‡å 
                const root = d3.hierarchy(this.hierarchyData);
                
                const cluster = d3.cluster()
                    .size([2 * Math.PI, this.radius])
                    .separation((a, b) => {
                        // å¢åŠ èŠ‚ç‚¹é—´åˆ†ç¦»åº¦ï¼Œé˜²æ­¢é‡å 
                        const baseSeparation = (a.parent == b.parent ? 1 : 2) / a.depth;
                        // æ ¹æ®èŠ‚ç‚¹ç±»å‹å’Œå­èŠ‚ç‚¹æ•°é‡è°ƒæ•´åˆ†ç¦»åº¦
                        const nodeFactor = Math.max(1, (a.children?.length || 1) * 0.3);
                        return baseSeparation * nodeFactor * 1.5; // å¢åŠ 1.5å€åˆ†ç¦»åº¦
                    });
                
                cluster(root);
                
                // åº”ç”¨é˜²ç¢°æ’ç®—æ³•
                this.nodes = root.descendants();
                this.links = root.links();
                this.applyCollisionDetection();
                
                // ç›´æ¥æ›´æ–°å¯è§†åŒ–å…ƒç´ ï¼Œé¿å…å¾ªç¯è°ƒç”¨
                this.updateBranches();
                this.updateNodes();
                this.updateLegend();
                this.updateSidebarColors();
            }
            
            applyCollisionDetection() {
                // ç®€å•çš„ç¢°æ’æ£€æµ‹å’Œä½ç½®è°ƒæ•´
                for (let i = 0; i < this.nodes.length; i++) {
                    for (let j = i + 1; j < this.nodes.length; j++) {
                        const nodeA = this.nodes[i];
                        const nodeB = this.nodes[j];
                        
                        // è½¬æ¢ä¸ºç¬›å¡å°”åæ ‡
                        const posA = this.project(nodeA.x, nodeA.y);
                        const posB = this.project(nodeB.x, nodeB.y);
                        
                        const distance = Math.sqrt(
                            Math.pow(posA.x - posB.x, 2) + Math.pow(posA.y - posB.y, 2)
                        );
                        
                        // å¦‚æœè·ç¦»å¤ªè¿‘ï¼Œè°ƒæ•´ä½ç½®
                        if (distance < this.minNodeDistance && distance > 0) {
                            const angle = Math.atan2(posB.y - posA.y, posB.x - posA.x);
                            const adjustDistance = (this.minNodeDistance - distance) / 2;
                            
                            // è°ƒæ•´èŠ‚ç‚¹Bçš„ä½ç½®
                            const newX = posB.x + Math.cos(angle) * adjustDistance;
                            const newY = posB.y + Math.sin(angle) * adjustDistance;
                            
                            // è½¬æ¢å›æåæ ‡
                            const newRadius = Math.sqrt(newX * newX + newY * newY);
                            const newAngle = Math.atan2(newY, newX) + Math.PI / 2;
                            
                            nodeB.x = newAngle < 0 ? newAngle + 2 * Math.PI : newAngle;
                            nodeB.y = Math.min(newRadius, this.radius);
                        }
                    }
                }
            }
            
            updateVisualization() {
                console.log(`ğŸ”„ [UPDATE] Starting visualization update for feature: ${this.currentColorFeature}`);
                
                // 1. é‡æ–°åˆ›å»ºæ ‘ç»“æ„ä»¥åæ˜ æ–°çš„ç‰¹å¾é€‰æ‹©
                this.createTreeStructure();
                
                // 2. é‡æ–°è®¡ç®—å¸ƒå±€
                const root = d3.hierarchy(this.hierarchyData);
                const cluster = d3.cluster()
                    .size([2 * Math.PI, this.radius])
                    .separation((a, b) => {
                        const baseSeparation = (a.parent == b.parent ? 1 : 2) / a.depth;
                        const nodeFactor = Math.max(1, (a.children?.length || 1) * 0.3);
                        return baseSeparation * nodeFactor * 1.5;
                    });
                
                cluster(root);
                this.nodes = root.descendants();
                this.links = root.links();
                this.applyCollisionDetection();
                
                console.log(`ğŸ”„ [UPDATE] Created ${this.nodes.length} nodes and ${this.links.length} links`);
                
                // 3. æ›´æ–°å¯è§†åŒ–å…ƒç´ 
                this.updateBranches();
                this.updateNodes();
                this.updateLegend();
                this.updateSidebarColors();
                
                console.log(`ğŸ”„ [UPDATE] Visualization update completed`);
            }
            
            updateBranches() {
                const linkGenerator = d3.linkRadial()
                    .angle(d => d.x)
                    .radius(d => d.y);
                
                const branches = this.g.selectAll(".branch")
                    .data(this.links);
                
                branches.enter()
                    .append("path")
                    .attr("class", "branch")
                    .merge(branches)
                    .transition()
                    .duration(750)
                    .attr("d", linkGenerator)
                    .attr("stroke", d => this.getBranchColor(d))
                    .attr("stroke-width", d => this.getBranchWidth(d))
                    .attr("stroke-opacity", d => this.getBranchOpacity(d));
                
                branches.exit().remove();
            }
            
            updateNodes() {
                const nodeGroups = this.g.selectAll(".node")
                    .data(this.nodes, d => d.data.name);
                
                const nodeEnter = nodeGroups.enter()
                    .append("g")
                    .attr("class", "node");
                
                // ç«‹å³ä¸ºæ–°èŠ‚ç‚¹è®¾ç½®é¢œè‰²ï¼Œä¸ç­‰å¾…transition
                const newCircles = nodeEnter.append("circle")
                    .attr("class", "node-circle")
                    .attr("r", d => this.getNodeSize(d))
                    .attr("fill", d => {
                        const color = this.getNodeColor(d);
                        console.log(`ğŸ¨ [NEW NODE] Setting node ${d.data.name} to color: ${color}`);
                        return color;
                    })
                    .attr("stroke", d => this.getNodeStrokeColor(d))
                    .attr("stroke-width", d => this.getNodeStrokeWidth(d))
                    .attr("fill-opacity", d => this.getNodeOpacity(d));
                
                nodeEnter.append("text")
                    .attr("class", "node-label");
                
                const nodeUpdate = nodeEnter.merge(nodeGroups);
                
                nodeUpdate
                    .transition()
                    .duration(750)
                    .attr("transform", d => {
                        const angle = (d.x - Math.PI / 2);
                        return `translate(${d.y * Math.cos(angle)}, ${d.y * Math.sin(angle)})`;
                    });
                
                // ç¡®ä¿é¢œè‰²æ­£ç¡®åº”ç”¨åˆ°èŠ‚ç‚¹
                nodeUpdate.select(".node-circle")
                    .transition()
                    .duration(750)
                    .attr("r", d => this.getNodeSize(d))
                    .attr("fill", d => {
                        const color = this.getNodeColor(d);
                        console.log(`ğŸ¨ [NODE UPDATE] Setting node ${d.data.name} to color: ${color}`);
                        return color;
                    })
                    .attr("stroke", d => this.getNodeStrokeColor(d))
                    .attr("stroke-width", d => this.getNodeStrokeWidth(d))
                    .attr("fill-opacity", d => this.getNodeOpacity(d));
                
                // æ”¹è¿›æ–‡å­—æ ‡ç­¾ä½ç½®ï¼Œé˜²æ­¢é‡å 
                nodeUpdate.select(".node-label")
                    .attr("dy", "0.32em")
                    .attr("x", d => {
                        // æ ¹æ®èŠ‚ç‚¹å¤§å°åŠ¨æ€è°ƒæ•´æ–‡å­—è·ç¦»
                        const nodeRadius = this.getNodeSize(d);
                        const textDistance = nodeRadius + 6;
                        return d.x < Math.PI ? textDistance : -textDistance;
                    })
                    .attr("text-anchor", d => d.x < Math.PI ? "start" : "end")
                    .attr("transform", d => {
                        // æ”¹è¿›æ–‡å­—æ—‹è½¬é€»è¾‘
                        const angle = (d.x - Math.PI / 2) * 180 / Math.PI;
                        // ç¡®ä¿æ–‡å­—åœ¨åˆç†çš„è§’åº¦èŒƒå›´å†…
                        if (d.x > Math.PI / 4 && d.x < 3 * Math.PI / 4) {
                            return `rotate(${angle})`;
                        } else if (d.x > 5 * Math.PI / 4 && d.x < 7 * Math.PI / 4) {
                            return `rotate(${angle + 180})`;
                        } else {
                            return d.x < Math.PI ? `rotate(${angle})` : `rotate(${angle + 180})`;
                        }
                    })
                    .classed("internal", d => d.data.type !== 'product')
                    .text(d => this.getNodeLabel(d))
                    .style("font-size", d => this.getNodeLabelSize(d))
                    .style("font-weight", d => d.data.type === 'root' ? "bold" : "normal")
                    .style("fill", d => this.getNodeLabelColor(d));
                
                // æ·»åŠ å®‰å…¨çš„äº‹ä»¶ç›‘å¬ï¼Œé¿å…é¢¤æŠ–
                nodeUpdate
                    .on("mouseover.tooltip", (event, d) => {
                        // ç§»é™¤ä»»ä½•ç°æœ‰çš„scale transformï¼Œé˜²æ­¢é¢¤æŠ–
                        d3.select(event.currentTarget).select(".node-circle")
                            .transition()
                            .duration(150)
                            .attr("r", d => this.getNodeSize(d) * 1.2)
                            .attr("stroke-width", d => this.getNodeStrokeWidth(d) + 1);
                        
                        this.showTooltip(event, d);
                    })
                    .on("mouseout.tooltip", (event, d) => {
                        // æ¢å¤åŸå§‹å¤§å°
                        d3.select(event.currentTarget).select(".node-circle")
                            .transition()
                            .duration(150)
                            .attr("r", d => this.getNodeSize(d))
                            .attr("stroke-width", d => this.getNodeStrokeWidth(d));
                        
                        this.hideTooltip();
                    });
                
                nodeGroups.exit().remove();
                
                // å¼ºåˆ¶é‡ç»˜ï¼Œç¡®ä¿é¢œè‰²æ­£ç¡®æ˜¾ç¤º
                console.log(`ğŸ¨ [NODE UPDATE] Updated ${nodeUpdate.size()} nodes`);
            }
            
            getNodeLabelColor(d) {
                // ä¸ºä¸åŒç±»å‹çš„èŠ‚ç‚¹ä½¿ç”¨ä¸åŒçš„æ–‡å­—é¢œè‰²
                const colors = {
                    'root': "#1f2937",
                    'category': "#374151",
                    'underwriter': "#4b5563",
                    'asset_type': "#6b7280",
                    'certification': "#6b7280",
                    'status': "#6b7280",
                    'product': "#9ca3af"
                };
                return colors[d.data.type] || "#4a5568";
            }
            
            getNodeSize(d) {
                const baseSize = {
                    'root': 12,
                    'category': 10,
                    'underwriter': 8,
                    'asset_type': 6,
                    'certification': 6,
                    'status': 6,
                    'product': 5
                };
                
                let size = baseSize[d.data.type] || 5;
                
                // æ ¹æ®å¤§å°ç‰¹å¾è°ƒæ•´
                if (this.currentSizeFeature !== 'none' && d.data.aggregatedData) {
                    const value = d.data.aggregatedData.totalScale || 0;
                    if (value > 0) {
                        const maxScale = d3.max(cleanedData, d => d.Scale_Billion_Yuan);
                        const sizeMultiplier = 1 + (value / maxScale) * 1.5;
                        size *= sizeMultiplier;
                    }
                }
                
                return Math.max(size, 3);
            }
            
            getNodeStrokeColor(d) {
                if (d.data.type === 'root') return "#4f46e5";
                // ä½¿ç”¨ç®€å•çš„ç°è‰²è¾¹æ¡†ï¼Œé¿å…é‡å¤é¢œè‰²è®¡ç®—
                return "#cbd5e0";
            }
            
            getNodeStrokeWidth(d) {
                const strokeWidths = {
                    'root': 3,
                    'category': 2.5,
                    'underwriter': 2,
                    'asset_type': 1.5,
                    'certification': 1.5,
                    'status': 1.5,
                    'product': 1
                };
                return strokeWidths[d.data.type] || 1;
            }
            
            getNodeOpacity(d) {
                const opacities = {
                    'root': 1,
                    'category': 0.9,
                    'underwriter': 0.8,
                    'asset_type': 0.75,
                    'certification': 0.75,
                    'status': 0.75,
                    'product': 0.85
                };
                return opacities[d.data.type] || 0.8;
            }
            
            getNodeLabel(d) {
                const name = d.data.name;
                const maxLength = {
                    'root': 12,
                    'category': 10,
                    'underwriter': 8,
                    'asset_type': 12,
                    'certification': 10,
                    'status': 8,
                    'product': 15
                };
                
                const limit = maxLength[d.data.type] || 15;
                if (name.length > limit) {
                    return name.substring(0, limit - 3) + "...";
                }
                return name;
            }
            
            getNodeLabelSize(d) {
                const sizes = {
                    'root': "13px",
                    'category': "11px",
                    'underwriter': "10px",
                    'asset_type': "9px",
                    'certification': "9px",
                    'status': "9px",
                    'product': "8px"
                };
                return sizes[d.data.type] || "9px";
            }
            
            getBranchColor(d) {
                return this.getNodeColor(d.target);
            }
            
            getBranchWidth(d) {
                const widths = {
                    'root': 3,
                    'category': 2.5,
                    'underwriter': 2,
                    'asset_type': 1.5,
                    'certification': 1.5,
                    'status': 1.5,
                    'product': 1
                };
                
                let width = widths[d.target.data.type] || 1;
                
                // æ ¹æ®æ•°æ®é‡è°ƒæ•´ç²—ç»†
                if (d.target.data.aggregatedData && d.target.data.aggregatedData.totalScale) {
                    const maxScale = d3.max(cleanedData, d => d.Scale_Billion_Yuan);
                    const scale = d.target.data.aggregatedData.totalScale;
                    width *= (1 + (scale / maxScale) * 0.5);
                }
                
                return Math.max(width, 0.5);
            }
            
            getBranchOpacity(d) {
                const opacities = {
                    'root': 1,
                    'category': 0.8,
                    'underwriter': 0.7,
                    'asset_type': 0.6,
                    'certification': 0.6,
                    'status': 0.6,
                    'product': 0.5
                };
                return opacities[d.target.data.type] || 0.6;
            }
            
            project(x, y) {
                const angle = (x - Math.PI / 2);
                return {
                    x: y * Math.cos(angle),
                    y: y * Math.sin(angle)
                };
            }
            
            updateLegend() {
                const legend = d3.select("#legend");
                legend.selectAll("*").remove();
                
                const featureName = features.color.find(f => f.id === this.currentColorFeature)?.name || this.currentColorFeature;
                legend.append("h4").text(`å›¾ä¾‹ - ${featureName}`);
                
                const feature = this.currentColorFeature;
                console.log(`ğŸ¨ [LEGEND] Updating legend for feature: ${feature}`);
                
                if (!colorSchemes[feature]) {
                    console.error(`ğŸ¨ [LEGEND] âŒ No color scheme found for ${feature}`);
                    return;
                }
                
                if (feature === 'Scale_Billion_Yuan') {
                    // è¿ç»­å˜é‡ï¼šå‘è¡Œè§„æ¨¡ - æ˜¾ç¤ºæ¢¯åº¦
                    const steps = 5;
                    const maxValue = 50;
                    for (let i = 0; i < steps; i++) {
                        const value = (maxValue * i) / (steps - 1);
                        const color = colorSchemes[feature](value);
                        console.log(`ğŸ¨ [LEGEND] Scale step ${i}: ${value}äº¿å…ƒ -> ${color}`);
                        
                        const item = legend.append("div").attr("class", "legend-item");
                        item.append("div")
                            .attr("class", "legend-color")
                            .style("background", color);
                        item.append("span").text(value.toFixed(1) + "äº¿å…ƒ");
                    }
                } else {
                    // åˆ†ç±»å˜é‡ï¼šè·å–æ‰€æœ‰å”¯ä¸€å€¼å¹¶æ˜¾ç¤º
                    const uniqueValues = [...new Set(cleanedData.map(d => d[feature]))].filter(v => v && v !== 'N/A');
                    console.log(`ğŸ¨ [LEGEND] Values for ${feature}:`, uniqueValues);
                    
                    uniqueValues.forEach(value => {
                        const color = colorSchemes[feature](value);
                        console.log(`ğŸ¨ [LEGEND] ${value} -> ${color}`);
                        
                        const item = legend.append("div").attr("class", "legend-item");
                        item.append("div")
                            .attr("class", "legend-color")
                            .style("background", color);
                        item.append("span").text(value);
                    });
                }
                
                console.log(`ğŸ¨ [LEGEND] Legend updated successfully`);
            }
            
            updateSidebarColors() {
                // æ›´æ–°é¢œè‰²ç‰¹å¾çš„æŒ‡ç¤ºå™¨
                d3.select("#color-features").selectAll(".feature-option").each(function(d, i) {
                    const featureId = features.color[i].id;
                    const color = this.getFeatureColor(featureId);
                    d3.select(this).select(".feature-color").style("background", color);
                }.bind(this));
            }
            
            showTooltip(event, d) {
                let content = `<strong>${d.data.name}</strong><br/>`;
                content += `ç±»å‹: ${d.data.type}<br/>`;
                
                if (d.data.aggregatedData) {
                    content += `äº§å“æ•°é‡: ${d.data.aggregatedData.count}<br/>`;
                    content += `æ€»è§„æ¨¡: ${d.data.aggregatedData.totalScale.toFixed(1)}äº¿å…ƒ<br/>`;
                    content += `å¹³å‡è§„æ¨¡: ${d.data.aggregatedData.avgScale.toFixed(1)}äº¿å…ƒ<br/>`;
                }
                
                if (d.data.type === 'product' && d.data.data) {
                    const product = d.data.data;
                    content = `
                        <strong>${product.Product_Name}</strong><br/>
                        è§„æ¨¡: ${product.Scale_Billion_Yuan}äº¿å…ƒ<br/>
                        æ‰¿é”€å•†: ${product.Lead_Underwriter}<br/>
                        çŠ¶æ€: ${product.Status}<br/>
                        èµ„äº§ç±»å‹: ${product.Underlying_Asset_Type}<br/>
                        è®¤è¯: ${product.Third_Party_Certification}<br/>
                        ç”³æŠ¥æ—¥æœŸ: ${product.Application_Date}<br/>
                        ç‰¹è‰²: ${product.Special_Features}
                    `;
                }
                
                this.tooltip
                    .style("opacity", 1)
                    .html(content)
                    .style("left", (event.pageX + 10) + "px")
                    .style("top", (event.pageY - 10) + "px");
            }
            
            hideTooltip() {
                this.tooltip.style("opacity", 0);
            }
            
            setupEventListeners() {
                // æœç´¢åŠŸèƒ½
                d3.select("#search-input").on("input", (event) => {
                    this.searchTerm = event.target.value.toLowerCase();
                    this.highlightSearchResults();
                });
                
                // çª—å£å¤§å°å˜åŒ–
                window.addEventListener("resize", () => {
                    this.width = window.innerWidth - 280;
                    this.height = window.innerHeight;
                    this.radius = Math.min(this.width, this.height) / 2 - 150;
                    
                    this.svg
                        .attr("width", this.width)
                        .attr("height", this.height);
                    
                    this.g.attr("transform", `translate(${this.width/2},${this.height/2})`);
                    
                    this.render();
                });
            }
            
            highlightSearchResults() {
                this.g.selectAll(".node")
                    .classed("highlighted", d => {
                        if (!this.searchTerm) return false;
                        return d.data.name.toLowerCase().includes(this.searchTerm);
                    });
            }
        }

        // åˆå§‹åŒ–å¯è§†åŒ–
        const visualization = new TreeOfLifeVisualization();

        // æ›´æ–°ç»Ÿè®¡ä¿¡æ¯
        const totalProducts = cleanedData.length;
        const totalScale = cleanedData.reduce((sum, d) => sum + d.Scale_Billion_Yuan, 0);
        const issuedProducts = cleanedData.filter(d => d.Status === 'å·²å‘è¡Œ').length;
        const uniqueUnderwriters = [...new Set(cleanedData.map(d => d.Lead_Underwriter))].length;

        d3.select("#total-products").text(totalProducts);
        d3.select("#total-scale").text(totalScale.toFixed(1) + "äº¿å…ƒ");
        d3.select("#issued-products").text(issuedProducts);
        d3.select("#underwriter-count").text(uniqueUnderwriters);
    </script>
</body>
</html> 